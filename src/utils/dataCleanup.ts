import { supabase } from "@/integrations/supabase/client";
import type { TablesInsert } from "@/integrations/supabase/types";

// Utility to remove empty fields from an object
export function removeEmptyFields<T extends Record<string, any>>(obj: T): Partial<T> {
  return Object.fromEntries(
    Object.entries(obj).filter(([_, value]) => {
      if (Array.isArray(value)) {
        return value.length > 0;
      }
      if (value === null || value === undefined || value === '') {
        return false;
      }
      return true;
    })
  ) as Partial<T>;
}

// Function to validate and parse date
function parseDate(dateStr: string | null): string | null {
  if (!dateStr) return null;
  
  // If it's clearly not a date, return null
  if (dateStr === 'Town Unknown' || dateStr === 'Unknown' || dateStr === 'N/A') {
    return null;
  }

  try {
    // Handle UK date format (DD/MM/YYYY)
    if (dateStr.includes('/')) {
      const [day, month, year] = dateStr.split('/').map(Number);
      const date = new Date(year, month - 1, day);
      if (!isNaN(date.getTime())) {
        return date.toISOString().split('T')[0];
      }
    }
    
    // Try standard date parsing
    const date = new Date(dateStr);
    if (!isNaN(date.getTime())) {
      return date.toISOString().split('T')[0];
    }
    console.log('Invalid date format:', dateStr);
    return null;
  } catch (error) {
    console.log('Error parsing date:', dateStr, error);
    return null;
  }
}

// Function to clean and format text fields
function cleanTextValue(value: string | null | undefined): string | null {
  if (!value) return null;
  value = value.trim();
  if (value.toLowerCase() === 'unknown' || value.toLowerCase() === 'n/a' || 
      value.toLowerCase() === 'postcode unknown' || value.toLowerCase() === 'town unknown') {
    return null;
  }
  return value;
}

// Function to normalize phone numbers
function normalizePhone(phone: string | null | undefined): string | null {
  if (!phone) return null;
  // Remove all non-numeric characters
  const cleaned = phone.replace(/\D/g, '');
  if (cleaned.length === 0) return null;
  return cleaned;
}

// Function to validate email
function validateEmail(email: string | null | undefined): string | null {
  if (!email) return null;
  email = email.trim().toLowerCase();
  // Basic email validation
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email) ? email : null;
}

// Transform member data to match Supabase schema
export function transformMemberForSupabase(memberData: any): TablesInsert<'members'> {
  console.log('Raw member data:', memberData);
  
  // Extract name from various possible fields
  const fullName = cleanTextValue(
    memberData["full_name"] || 
    memberData["Name"] || 
    memberData["Full Name"] || 
    memberData["FullName"] || 
    memberData["name"]
  );

  if (!fullName) {
    console.error('Missing name in member data:', memberData);
    throw new Error('Member name is required');
  }

  const cleanedData = removeEmptyFields({
    full_name: fullName,
    member_number: memberData.member_number || '', // Will be generated by trigger if empty
    address: cleanTextValue(memberData["address"] || memberData["Address"]),
    email: validateEmail(memberData["email"] || memberData["Email"]),
    gender: cleanTextValue(memberData["gender"] || memberData["Gender"]),
    marital_status: cleanTextValue(memberData["marital_status"] || memberData["Marital Status"]),
    phone: normalizePhone(memberData["phone"] || memberData["Phone"] || memberData["Mobile"]),
    date_of_birth: parseDate(memberData["date_of_birth"] || memberData["Date of Birth"]),
    postcode: cleanTextValue(memberData["postcode"] || memberData["Postcode"]),
    town: cleanTextValue(memberData["town"] || memberData["Town"]),
    verified: memberData["verified"] || memberData["Verified"] || false,
    status: 'active',
  });

  console.log('Transformed member data:', cleanedData);
  return cleanedData as TablesInsert<'members'>;
}
